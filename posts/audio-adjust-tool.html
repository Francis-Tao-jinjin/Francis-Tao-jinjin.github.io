<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Learn how to build a personal website using Next.js"/><meta property="og:image" content="https://og-image.now.sh/Francis%20Next.js%20Sample%20Website.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Francis Next.js Sample Website"/><meta name="teitter:card" content="summary_large_image"/><title>Audio Adjustment Tool</title><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/e701d5136af2eef7bbe0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e701d5136af2eef7bbe0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/ca491a2f2dad37bc344d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ca491a2f2dad37bc344d.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-83e64d9f15f816d3a120.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9d524150d48315f49e80.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ff0a5790a80e83d7223b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3a694fa933cddd65416a.js" as="script"/><link rel="preload" href="/_next/static/chunks/df27990eef8845831ef4a3353c0adb327953b68f.b69d60b0cedb60692bff.js" as="script"/><link rel="preload" href="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a80097bea88316e5b19e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-81175210d41b2c86eef6.js" as="script"/></head><body><div id="__next"><div class="layout_container__2t4v2"><header class="layout_header__2rhWq"><a href="/"><img src="/images/profile.png" class="layout_headerImage__2h5On utils_borderCircle__13qdJ" alt="Francis Tao"/></a><h2 class="utils_headingLg__de7p0"><a class="utils_colorInherit__3Gudf" href="/">Francis Tao</a></h2></header><article><h1 class="utils_headingXl__1XecN">Audio Adjustment Tool</h1><div class="utils_lightText__12Ckm"><time dateTime="2020-08-10">August 10, 2020</time></div><div><h1 class="text-3xl font-medium mb-2 mt-3">Audio Adjustment Tool Of Box3 Game Editor</h1>
<div class='m-5'></div>
<img src="/images/audio-adjust/audio-upload.gif" alt="audio upload" style="width:400px; margin:auto"/>
<div class='m-5'></div>
<p>This is a tool for uploading and simply processing audio in the box3 game editor. I have written a component specifically for this functionality, which in addition to React, will also involve the WebAudio API and canvas 2d.</p>
<div class='m-5'></div>
The main functions of this component include: playing and pausing audio, cropping audio, and providing convenient UI controls and visual feedback for these functions.
<div class='m-5'></div>
For those who are not familiar with WebAudio API. All you need to know is the 'Audio' we talk about is actually a kind of data buffer that we call <code class='il'>AudioBuffer</code>. Whether it's playing or cropping or even adding sound effects, it's all about the buffer in the end.
<div class='m-5'></div>
To play an audioBuffer, we need to create an <code class='il'>AudioBufferSourceNode</code>, be noticed, an AudioBufferSourceNode can only be start and stop once. Otherwise, your javascript gonna throw error.
<div class='m-5'></div>
Now we clear that we need to implement a class to handle all the operations to the audioBuffer and a React component to handle UI interaction.
<div class='m-5'></div>
We can call that  class 'AudioPlayer', it need to support basic <code class='il'>play</code> and <code class='il'>stop</code>, beside, user may want to start playback from any position of the audio, and the selected interval should support loop playback.
<div class='preCodeBlock'></div>
<pre><code class="language-javascript">class AudioPlayer {
    private _state = 'stopped';
    private _offset = 0;
    private _startTime = 0;
    private _finished = false;
    constructor(
        private audioBuffer:AudioBuffer,
        private audioContext:AudioContext) {
    }

    private _loopStart = 0;
    public set loopStart(value:number) {
        ...
    }

    private _loopEnd = Infinity;
    public set loopEnd(value:number) {
        ...
    }

    private _loop = false;
    public set loop(flag:boolean) {
        this._loop = flag;
    }

    private _source:AudioBufferSourceNode|null = null;

    private now() {
        return this.audioContext.currentTime;
    }

    public start(startTime?:number, offset?:number) {
        ...
    }

    public get state() {
        return this._state;
    }

    public get finished() {
        return this._finished;
    }

    public stop(time?:number) {
        ...
    }

    public seek(offset:number, time:number) {
        ...
    }
}
</code></pre>
<p>The start method receive two optional param, <code class='il'>startTime</code> refer to the global time of 'AudioContex', if you want to start at the time you call the method, just pass  <code class='il'>audioContext.currentTime</code> to it. <code class='il'>offset</code> refer to the duration of the audio. If an audio is 1.5s long and you wang to start playback from the 0.5s, then the <code class='il'>offset</code> is 0.5 .</p>
<p>Here is how I implement the <code class='il'>start</code> and <code class='il'>stop</code>method:</p>
<div class='preCodeBlock'></div>
<pre><code class="language-javascript">public start(startTime?:number, offset?:number) {
    if (startTime === undefined) {
        startTime = this.now();
    }
    if (offset === undefined) {
        if (this._loop) {
            offset = this._loopStart;
        } else {
            offset = 0;
        }
    }
    this._source = this.audioContext.createBufferSource();
    this._source.connect(this.audioContext.destination);
    this._source.buffer = this.audioBuffer;
    this._source.onended = () => {
        const now = this.now();
        if (!this._loop) {
            const passTime = (now - this._startTime + this._offset);
            if (passTime >= this.audioBuffer.duration) {
                this._finished = true;
            } else if (this.audioBuffer.duration - passTime >= 0 &#x26;&#x26;
                        this.audioBuffer.duration - passTime &#x3C;= 1e-4) {
                this._finished = true;
            }
        }
    };
    this._source.loop = this._loop;
    this._source.loopStart = this._loopStart;
    this._source.loopEnd = Math.min(this._loopEnd, this.audioBuffer.duration);
    this._state = 'started';
    this._source.start(startTime, offset);
    this._offset = offset;
    this._startTime = startTime;
}

public stop(time?:number) {
    if (time === undefined) {
        time = this.now();
    }
    if (this._source) {
        this._source.stop(time);
        this._source.disconnect();
        this._state = 'stopped';
    }
}
</code></pre>
<p>As for the <code class='il'>seek</code>, you can simply call <code class='il'>stop</code> then call <code class='il'>start</code> in it.</p>
<h2 class="text-xl font-medium mb-2 mt-3">Drawing the Waveform</h2>
<p>Drawing the waveform of audiobuffer is fairly easy. You don't need to install another package to do it, all you need to do is some simple calculation. Many people like to install a bunch of extra modules to solve a small problem, but I prefer not to install them if I don't need to. This allows you to keep your code light weight, and you can learn a lot of new things in the process.</p>
<div class='preCodeBlock'></div>
<pre><code class="language-javascript">function computeWaveForm(container:HTMLDivElement, buffer:AudioBuffer) {
    const peaks:number[] = [];
    const chann0 = (buffer.getChannelData(0) as ArrayBuffer);
    // const sampleSize = props.buffer.length / props.waveformWidth;
    const sampleSize = buffer.length / container.clientWidth;
    const sampleStep = ~~(sampleSize / 10) || 1;

    for (let i = 0; i &#x3C; container.clientWidth; i++) {
    // for (let i = 0; i &#x3C; props.waveformWidth; i++) {
        const start = ~~(i * sampleSize);
        const end = ~~(start + sampleSize);
        let topCount = 0;
        let bottomCount = 0;
        let bottom = 0;
        let top = 0;
        for (var j = start; j &#x3C; end; j += sampleStep) {
            const value = chann0[j];
            if (value > 0) {
                bottom += value * value;
                bottomCount++;
            }
            if (value &#x3C; 0) {
                top += value * value;
                topCount++;
            }
        }
        peaks[2 * i] = Math.sqrt(bottom / bottomCount) * 256;
        peaks[2 * i + 1] = -Math.sqrt(top / topCount) * 256;
    }
    return peaks;
}

function drawWaveForm(canvasEle:HTMLCanvasElement, container:HTMLDivElement, peaks:number[], waveformHeight:number) {
    if (canvasEle &#x26;&#x26; container) {
        const cvsCtx = canvasEle.getContext('2d');
        if (cvsCtx) {
            let dirty = false;
            if (canvasEle.height !== waveformHeight) {
                dirty = true;
                canvasEle.style.height = waveformHeight + 'px';
                canvasEle.height = waveformHeight;
            }
            if (canvasEle.width !== container.clientWidth) {
                dirty = true;
                canvasEle.style.width = container.clientWidth + 'px';
                canvasEle.width = container.clientWidth;
            }
            if (dirty) {
                cvsCtx.translate(.5, waveformHeight / 2);
                cvsCtx.scale(.5, waveformHeight / 256);
                cvsCtx.lineWidth = 2;
            } else {
                cvsCtx.setTransform(1, 0, 0, 1, 0, 0);
                cvsCtx.translate(.5, waveformHeight / 2);
                cvsCtx.scale(.5, waveformHeight / 256);
            }

            cvsCtx.clearRect(0, 0, canvasEle.width, canvasEle.height);
            cvsCtx.strokeStyle = 'white';
            cvsCtx.fillStyle = 'white';
            const start = 0;
            const end = container.clientWidth;
            // const end = props.waveformWidth;
            for (let e = start; e &#x3C; end; e += 1) {
                // const ptr = 2 * (e % props.waveformWidth);
                const ptr = 2 * (e % container.clientWidth);
                let xPos = 2 * (e - start);
                let top = peaks[ptr + 1];
                let bottom = peaks[ptr];
                if (top >= -.5 &#x26;&#x26; bottom &#x3C;= .5) {
                    const i = xPos;
                    for (; e &#x3C; end; e += 1) {
                        // const a = 2 * (e % props.waveformWidth);
                        const a = 2 * (e % container.clientWidth);
                        if (peaks[a + 1] &#x3C; -.5 || peaks[a] > .5) {
                            e -= 1;
                            break;
                        }
                        xPos = 2 * (e - start);
                    }
                    if (i === xPos) {
                        cvsCtx.moveTo(xPos, -.5);
                        cvsCtx.lineTo(xPos, .5);
                    } else {
                        cvsCtx.stroke();
                        cvsCtx.lineWidth = 1;
                        cvsCtx.beginPath();
                        cvsCtx.moveTo(i - .5, 0);
                        cvsCtx.lineTo(xPos + .5, 0);
                        cvsCtx.stroke();
                        cvsCtx.lineWidth = 2;
                        cvsCtx.beginPath();
                    }
                } else {
                    if (top > -0.5) {
                        top = -0.5;
                    }
                    if (bottom &#x3C; 0.5) {
                        bottom = 0.5;
                    }
                    cvsCtx.moveTo(xPos, top);
                    cvsCtx.lineTo(xPos, bottom);
                }
            }
            cvsCtx.stroke();
        }
    }
}
</code></pre>
<p>Besides, there is also a mini music player in Box3 editor implemented in a similar way.</p>
<div class='m-5'></div>
<img src="/images/audio-adjust/mini-player.gif" alt="mini audio player" style="width:320px; margin:auto"/>
<div class='m-5'></div>
</div></article><div class="layout_backToHome__1vZsp"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"audio-adjust-tool","contentHtml":"\u003ch1 class=\"text-3xl font-medium mb-2 mt-3\"\u003eAudio Adjustment Tool Of Box3 Game Editor\u003c/h1\u003e\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\n\u003cimg src=\"/images/audio-adjust/audio-upload.gif\" alt=\"audio upload\" style=\"width:400px; margin:auto\"/\u003e\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\n\u003cp\u003eThis is a tool for uploading and simply processing audio in the box3 game editor. I have written a component specifically for this functionality, which in addition to React, will also involve the WebAudio API and canvas 2d.\u003c/p\u003e\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\nThe main functions of this component include: playing and pausing audio, cropping audio, and providing convenient UI controls and visual feedback for these functions.\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\nFor those who are not familiar with WebAudio API. All you need to know is the 'Audio' we talk about is actually a kind of data buffer that we call \u003ccode class='il'\u003eAudioBuffer\u003c/code\u003e. Whether it's playing or cropping or even adding sound effects, it's all about the buffer in the end.\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\nTo play an audioBuffer, we need to create an \u003ccode class='il'\u003eAudioBufferSourceNode\u003c/code\u003e, be noticed, an AudioBufferSourceNode can only be start and stop once. Otherwise, your javascript gonna throw error.\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\nNow we clear that we need to implement a class to handle all the operations to the audioBuffer and a React component to handle UI interaction.\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\nWe can call that  class 'AudioPlayer', it need to support basic \u003ccode class='il'\u003eplay\u003c/code\u003e and \u003ccode class='il'\u003estop\u003c/code\u003e, beside, user may want to start playback from any position of the audio, and the selected interval should support loop playback.\n\u003cdiv class='preCodeBlock'\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass AudioPlayer {\n    private _state = 'stopped';\n    private _offset = 0;\n    private _startTime = 0;\n    private _finished = false;\n    constructor(\n        private audioBuffer:AudioBuffer,\n        private audioContext:AudioContext) {\n    }\n\n    private _loopStart = 0;\n    public set loopStart(value:number) {\n        ...\n    }\n\n    private _loopEnd = Infinity;\n    public set loopEnd(value:number) {\n        ...\n    }\n\n    private _loop = false;\n    public set loop(flag:boolean) {\n        this._loop = flag;\n    }\n\n    private _source:AudioBufferSourceNode|null = null;\n\n    private now() {\n        return this.audioContext.currentTime;\n    }\n\n    public start(startTime?:number, offset?:number) {\n        ...\n    }\n\n    public get state() {\n        return this._state;\n    }\n\n    public get finished() {\n        return this._finished;\n    }\n\n    public stop(time?:number) {\n        ...\n    }\n\n    public seek(offset:number, time:number) {\n        ...\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe start method receive two optional param, \u003ccode class='il'\u003estartTime\u003c/code\u003e refer to the global time of 'AudioContex', if you want to start at the time you call the method, just pass  \u003ccode class='il'\u003eaudioContext.currentTime\u003c/code\u003e to it. \u003ccode class='il'\u003eoffset\u003c/code\u003e refer to the duration of the audio. If an audio is 1.5s long and you wang to start playback from the 0.5s, then the \u003ccode class='il'\u003eoffset\u003c/code\u003e is 0.5 .\u003c/p\u003e\n\u003cp\u003eHere is how I implement the \u003ccode class='il'\u003estart\u003c/code\u003e and \u003ccode class='il'\u003estop\u003c/code\u003emethod:\u003c/p\u003e\n\u003cdiv class='preCodeBlock'\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003epublic start(startTime?:number, offset?:number) {\n    if (startTime === undefined) {\n        startTime = this.now();\n    }\n    if (offset === undefined) {\n        if (this._loop) {\n            offset = this._loopStart;\n        } else {\n            offset = 0;\n        }\n    }\n    this._source = this.audioContext.createBufferSource();\n    this._source.connect(this.audioContext.destination);\n    this._source.buffer = this.audioBuffer;\n    this._source.onended = () =\u003e {\n        const now = this.now();\n        if (!this._loop) {\n            const passTime = (now - this._startTime + this._offset);\n            if (passTime \u003e= this.audioBuffer.duration) {\n                this._finished = true;\n            } else if (this.audioBuffer.duration - passTime \u003e= 0 \u0026#x26;\u0026#x26;\n                        this.audioBuffer.duration - passTime \u0026#x3C;= 1e-4) {\n                this._finished = true;\n            }\n        }\n    };\n    this._source.loop = this._loop;\n    this._source.loopStart = this._loopStart;\n    this._source.loopEnd = Math.min(this._loopEnd, this.audioBuffer.duration);\n    this._state = 'started';\n    this._source.start(startTime, offset);\n    this._offset = offset;\n    this._startTime = startTime;\n}\n\npublic stop(time?:number) {\n    if (time === undefined) {\n        time = this.now();\n    }\n    if (this._source) {\n        this._source.stop(time);\n        this._source.disconnect();\n        this._state = 'stopped';\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs for the \u003ccode class='il'\u003eseek\u003c/code\u003e, you can simply call \u003ccode class='il'\u003estop\u003c/code\u003e then call \u003ccode class='il'\u003estart\u003c/code\u003e in it.\u003c/p\u003e\n\u003ch2 class=\"text-xl font-medium mb-2 mt-3\"\u003eDrawing the Waveform\u003c/h2\u003e\n\u003cp\u003eDrawing the waveform of audiobuffer is fairly easy. You don't need to install another package to do it, all you need to do is some simple calculation. Many people like to install a bunch of extra modules to solve a small problem, but I prefer not to install them if I don't need to. This allows you to keep your code light weight, and you can learn a lot of new things in the process.\u003c/p\u003e\n\u003cdiv class='preCodeBlock'\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction computeWaveForm(container:HTMLDivElement, buffer:AudioBuffer) {\n    const peaks:number[] = [];\n    const chann0 = (buffer.getChannelData(0) as ArrayBuffer);\n    // const sampleSize = props.buffer.length / props.waveformWidth;\n    const sampleSize = buffer.length / container.clientWidth;\n    const sampleStep = ~~(sampleSize / 10) || 1;\n\n    for (let i = 0; i \u0026#x3C; container.clientWidth; i++) {\n    // for (let i = 0; i \u0026#x3C; props.waveformWidth; i++) {\n        const start = ~~(i * sampleSize);\n        const end = ~~(start + sampleSize);\n        let topCount = 0;\n        let bottomCount = 0;\n        let bottom = 0;\n        let top = 0;\n        for (var j = start; j \u0026#x3C; end; j += sampleStep) {\n            const value = chann0[j];\n            if (value \u003e 0) {\n                bottom += value * value;\n                bottomCount++;\n            }\n            if (value \u0026#x3C; 0) {\n                top += value * value;\n                topCount++;\n            }\n        }\n        peaks[2 * i] = Math.sqrt(bottom / bottomCount) * 256;\n        peaks[2 * i + 1] = -Math.sqrt(top / topCount) * 256;\n    }\n    return peaks;\n}\n\nfunction drawWaveForm(canvasEle:HTMLCanvasElement, container:HTMLDivElement, peaks:number[], waveformHeight:number) {\n    if (canvasEle \u0026#x26;\u0026#x26; container) {\n        const cvsCtx = canvasEle.getContext('2d');\n        if (cvsCtx) {\n            let dirty = false;\n            if (canvasEle.height !== waveformHeight) {\n                dirty = true;\n                canvasEle.style.height = waveformHeight + 'px';\n                canvasEle.height = waveformHeight;\n            }\n            if (canvasEle.width !== container.clientWidth) {\n                dirty = true;\n                canvasEle.style.width = container.clientWidth + 'px';\n                canvasEle.width = container.clientWidth;\n            }\n            if (dirty) {\n                cvsCtx.translate(.5, waveformHeight / 2);\n                cvsCtx.scale(.5, waveformHeight / 256);\n                cvsCtx.lineWidth = 2;\n            } else {\n                cvsCtx.setTransform(1, 0, 0, 1, 0, 0);\n                cvsCtx.translate(.5, waveformHeight / 2);\n                cvsCtx.scale(.5, waveformHeight / 256);\n            }\n\n            cvsCtx.clearRect(0, 0, canvasEle.width, canvasEle.height);\n            cvsCtx.strokeStyle = 'white';\n            cvsCtx.fillStyle = 'white';\n            const start = 0;\n            const end = container.clientWidth;\n            // const end = props.waveformWidth;\n            for (let e = start; e \u0026#x3C; end; e += 1) {\n                // const ptr = 2 * (e % props.waveformWidth);\n                const ptr = 2 * (e % container.clientWidth);\n                let xPos = 2 * (e - start);\n                let top = peaks[ptr + 1];\n                let bottom = peaks[ptr];\n                if (top \u003e= -.5 \u0026#x26;\u0026#x26; bottom \u0026#x3C;= .5) {\n                    const i = xPos;\n                    for (; e \u0026#x3C; end; e += 1) {\n                        // const a = 2 * (e % props.waveformWidth);\n                        const a = 2 * (e % container.clientWidth);\n                        if (peaks[a + 1] \u0026#x3C; -.5 || peaks[a] \u003e .5) {\n                            e -= 1;\n                            break;\n                        }\n                        xPos = 2 * (e - start);\n                    }\n                    if (i === xPos) {\n                        cvsCtx.moveTo(xPos, -.5);\n                        cvsCtx.lineTo(xPos, .5);\n                    } else {\n                        cvsCtx.stroke();\n                        cvsCtx.lineWidth = 1;\n                        cvsCtx.beginPath();\n                        cvsCtx.moveTo(i - .5, 0);\n                        cvsCtx.lineTo(xPos + .5, 0);\n                        cvsCtx.stroke();\n                        cvsCtx.lineWidth = 2;\n                        cvsCtx.beginPath();\n                    }\n                } else {\n                    if (top \u003e -0.5) {\n                        top = -0.5;\n                    }\n                    if (bottom \u0026#x3C; 0.5) {\n                        bottom = 0.5;\n                    }\n                    cvsCtx.moveTo(xPos, top);\n                    cvsCtx.lineTo(xPos, bottom);\n                }\n            }\n            cvsCtx.stroke();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBesides, there is also a mini music player in Box3 editor implemented in a similar way.\u003c/p\u003e\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\n\u003cimg src=\"/images/audio-adjust/mini-player.gif\" alt=\"mini audio player\" style=\"width:320px; margin:auto\"/\u003e\n\u003cdiv class='m-5'\u003e\u003c/div\u003e\n","title":"Audio Adjustment Tool","pic":"/images/audio-adjust/1.png","description":"This is a tool for uploading and simply processing audio in the box3 platform. The technology used is React and WebAudio API.","date":"2020-08-10"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"audio-adjust-tool"},"buildId":"it3oNUDbUo-2YEcwPr6Wi","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ff94e68042added27a93.js"></script><script src="/_next/static/chunks/main-83e64d9f15f816d3a120.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.9d524150d48315f49e80.js" async=""></script><script src="/_next/static/chunks/commons.ff0a5790a80e83d7223b.js" async=""></script><script src="/_next/static/chunks/pages/_app-3a694fa933cddd65416a.js" async=""></script><script src="/_next/static/chunks/df27990eef8845831ef4a3353c0adb327953b68f.b69d60b0cedb60692bff.js" async=""></script><script src="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a80097bea88316e5b19e.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-81175210d41b2c86eef6.js" async=""></script><script src="/_next/static/it3oNUDbUo-2YEcwPr6Wi/_buildManifest.js" async=""></script><script src="/_next/static/it3oNUDbUo-2YEcwPr6Wi/_ssgManifest.js" async=""></script></body></html>
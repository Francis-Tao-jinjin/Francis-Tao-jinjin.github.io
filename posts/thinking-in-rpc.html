<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Francis Tao-Jinjin Next.js GitHub Pages"/><meta property="og:image" content="https://og-image.now.sh/Francis%20Tao-Jinjin%20Next.js%20GitHub%20Pages.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Francis Tao-Jinjin Next.js GitHub Pages"/><meta name="teitter:card" content="summary_large_image"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css"/><title>Thinking In RPC</title><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/525ade0da8ac601406c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/525ade0da8ac601406c9.css" data-n-g=""/><link rel="preload" href="/_next/static/css/5becdbcfc90fd0f7b1ef.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5becdbcfc90fd0f7b1ef.css" data-n-g=""/><link rel="preload" href="/_next/static/css/230b7ec8cac95abf8a71.css" as="style"/><link rel="stylesheet" href="/_next/static/css/230b7ec8cac95abf8a71.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-b6d312587e2afb5b7e03.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9d524150d48315f49e80.js" as="script"/><link rel="preload" href="/_next/static/chunks/7a55d4b5.210d3c80a2b0e2401248.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.0a849237534e67e84d9a.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-929cb4bd00d30619cb94.js" as="script"/><link rel="preload" href="/_next/static/chunks/df27990eef8845831ef4a3353c0adb327953b68f.6ebe35bf6c0aadc1eb95.js" as="script"/><link rel="preload" href="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a80097bea88316e5b19e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-67fc6c234c356062955a.js" as="script"/></head><body><div id="__next"><div><div class="layout_container__2t4v2"><header class="layout_header__2rhWq"><a href="/"><img src="/images/profile.png" class="layout_headerImage__2h5On utils_borderCircle__13qdJ" alt="Francis Tao"/></a><h2 class="utils_headingLg__de7p0"><a class="utils_colorInherit__3Gudf" href="/">Francis Tao</a></h2></header><article><h1 class="utils_headingXl__1XecN">Thinking In RPC</h1><div class="utils_lightText__12Ckm"><time dateTime="2019-08-01">August 1, 2019</time></div><div><div class='markdown'></div>
<h1>Remote Procedure Calls</h1>
<p>Today, whenever we think about how to implement client-server interaction, REST API is the pattern that always come first. Well, although it is tried and true, it is not the only pattern we can use. Before REST API become popular,  RPC has been used in various situations. Ever since the Nodejs take a place in a server-side language, adopt the RPC pattern for designing the client-server API may be a very interesting approach.</p>
<p>Before we go further into this, we need to understand what is RPC, and why it is different from REST API as well as we shouldn’t use the rule of the REST to judge the RPC.</p>
<p>Remote Procedure Call (RPC) is a protocol that one program can use to request a service from a program localted in another computer on a network without having to understand the network’s details.</p>
<ul>
<li>However, because we are dealing with an environment in which the processes are excuting on separate systems, we must use a <strong>message based communication scheme</strong> to provide remote service.</li>
<li>The RPC system hides the details that allow communication to take place by providing a stub on the client side.</li>
<li>Typically, a sparate stub exist for each separate remote procedure.</li>
<li>When the client invokes a remote procedure, the RPC system call the approriate stub, passing it the parameters provided to the remote procudure. This stub locates the port ont the server and marshals the parameters.</li>
<li>Parameter marshalling involves packaging the parameters into a form that can be transmitted over a network.</li>
<li>The stub then transmits a message to the server using message passing.</li>
<li>A similar stub on the server side receives this message and invokes the procedure on the server.</li>
<li>If necessary, return values are passed back to the client using the same technique.</li>
</ul>
<p>The REST API, in contrast, models the various entities within the problem domain as resources, and uses HTTP verbs to represent transactions against these resources - POST to create, PUT to update, and GET to read. All of these verbs, invoked on the same URL, provide different functionality. Common HTTP return codes are used to convey status of the requests.</p>
<ul>
<li>REST must be stateless: not persisting sessions between requests.</li>
<li>Responses should declare cacheablility: helps your API scale if clients respect the rules.</li>
<li>REST focuses on uniformity: if you’re using HTTP you should utilize HTTP features whenever possible, instead of inventing conventions.</li>
</ul>
<p>In short, RPC treats the client’s request to the server as a call to a remote function while REST API see it as an acquisition of resources.</p>
<h2>Remote and Async</h2>
<p>This is the moment when JavaScript become really handy. The ability of handling async function is simply inside JavaScript’s veins. While in RPC, what we need to achieve just a little bit different, that we need to hide all the detail of making http request and turn the remote function invoke looks like call a local async function.</p>
<h3>Design the architecture</h3>
<p><strong>protocol</strong></p>
<p>A protocol is the description of the api between a client and a server. You can define multiple different protocols in your application for different functionalities, with equal number of client-server pairs each dedicated to one of the protocols.</p>
<p><strong>client/server</strong></p>
<p>All communications are initiated by client. Client calls, server executes. Client can only communicate with server through the api defined by the protocol, which means they both need to “understand” the same protocol.</p>
<p><strong>transport</strong></p>
<p>Client and server take care of invocation and execution, while transport takes care of message passing. Transports are protocol-agnostic. It means different servers can share the same server transport. Similarly, different clients can share one client transport.</p>
<p>Ok, finished talking, let’s try to build a real RPC library, we also gonna write a simple demo program to show how to use this library. You can checkout out <a href="https://github.com/Francis-Tao-jinjin/web-app-setup/tree/rpc">this repo</a> to see the final code. The project is setup base on the <a href="https://francis-tao-jinjin.github.io/posts/web-app-setup-1">WebApp setup from scratch</a>.</p>
<h3>Protocol</h3>
<p>In this project, we are using <em>mudb/muSchema</em> and <em>TypeScript</em>. First, we gonna define the type/interface for the RPC protocol, which contain all the api information. The api data could be as simple as a key value table.</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> RPCTableEntry&lt;ArgsSchema <span class="hljs-keyword">extends</span> MuSchema&lt;<span class="hljs-built_in">any</span>&gt;, ReturnSchema <span class="hljs-keyword">extends</span> MuSchema&lt;<span class="hljs-built_in">any</span>&gt;&gt; = {
    <span class="hljs-attr">arg</span>:ArgsSchema;
    reg:ReturnSchema;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> RPCTable = {
    [method:<span class="hljs-built_in">string</span>]:RPCTableEntry&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> RPCProtocol&lt;AnyRPCTable <span class="hljs-keyword">extends</span> RPCTable&gt; = {
    <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;
    api:AnyRPCTable;
};
</code></pre>
<p>For each protocol object, it will need a unique name and an API object which list all the basic info of the remote function. The unique protocol name, in this case, can be seen as something like a namespace and will also be used in URL path.</p>
<p>Here is code show how to create a actual protocol object accroding to the type definitation.</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">import</span> { MuUTF8, MuStruct, MuFloat64, MuVoid } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mudb/src/schema&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CaculatorRPCSchema = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;caculator-service&#x27;</span>,
    <span class="hljs-attr">api</span>: {
        <span class="hljs-attr">hello</span>: {
            <span class="hljs-attr">arg</span>: <span class="hljs-keyword">new</span> MuVoid(),
            <span class="hljs-attr">ret</span>: <span class="hljs-keyword">new</span> MuUTF8(),
        },
        <span class="hljs-attr">add</span>: {
            <span class="hljs-attr">arg</span>: <span class="hljs-keyword">new</span> MuStruct({
                <span class="hljs-attr">a</span>: <span class="hljs-keyword">new</span> MuFloat64(),
                <span class="hljs-attr">b</span>: <span class="hljs-keyword">new</span> MuFloat64(),
            }),
            <span class="hljs-attr">ret</span>: <span class="hljs-keyword">new</span> MuFloat64(),
        },
        ...
    }
}
</code></pre>
<p>After we have define the protocol, we need a helper class that let both server and client understand the protocol:</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCSchemas</span>&lt;<span class="hljs-title">Protocol</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RPCProtocol</span>&lt;<span class="hljs-title">any</span>&gt;&gt; </span>{
    <span class="hljs-keyword">public</span> errorSchema = <span class="hljs-keyword">new</span> MuUTF8();
    <span class="hljs-keyword">public</span> tokenSchema = <span class="hljs-keyword">new</span> Muvarint();

    <span class="hljs-keyword">public</span> argSchema:MuUnion&lt;{
        [key <span class="hljs-keyword">in</span> keyof Protocol[<span class="hljs-string">&#x27;api&#x27;</span>]]:Protocol[<span class="hljs-string">&#x27;api&#x27;</span>][<span class="hljs-string">&#x27;arg&#x27;</span>];
    }&gt;;

    <span class="hljs-keyword">public</span> retSchema:MuUnion&lt;{
        [key <span class="hljs-keyword">in</span> keyof Protocol[<span class="hljs-string">&#x27;api&#x27;</span>]]:Protocol[<span class="hljs-string">&#x27;api&#x27;</span>][<span class="hljs-string">&#x27;ret&#x27;</span>];
    }&gt;;

    <span class="hljs-keyword">public</span> responseSchema:MuUnion&lt;{
        <span class="hljs-attr">success</span>:RPCSchemas&lt;Protocol&gt;[<span class="hljs-string">&#x27;retSchema&#x27;</span>];
        error:RPCSchemas&lt;Protocol&gt;[<span class="hljs-string">&#x27;errorSchema&#x27;</span>];
    }&gt;;

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> protocol:Protocol</span>)</span> {
        <span class="hljs-keyword">const</span> argTable:<span class="hljs-built_in">any</span> = {};
        <span class="hljs-keyword">const</span> retTable:<span class="hljs-built_in">any</span> = {};
        <span class="hljs-keyword">const</span> methods = <span class="hljs-built_in">Object</span>.keys(protocol.api);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; methods.length; i++&gt;) {
            <span class="hljs-keyword">const</span> m = methods[i];
            <span class="hljs-keyword">const</span> s = protocol.api[m];
            argTable[m] = s.arg;
            retTable[m] = s.ret;
        }
        <span class="hljs-built_in">this</span>.argSchema = <span class="hljs-keyword">new</span> MuUnion(argTable);
        <span class="hljs-built_in">this</span>.retSchema = <span class="hljs-keyword">new</span> MuUnion(retTable);

        <span class="hljs-built_in">this</span>.responseSchema = <span class="hljs-keyword">new</span> MuUnion({
            <span class="hljs-attr">success</span>: <span class="hljs-built_in">this</span>.retSchema,
            <span class="hljs-attr">error</span>: <span class="hljs-built_in">this</span>.errorSchema,
        });
    }
}
</code></pre>
<h3>Transport</h3>
<p>Before we start implementing the stubs for both client and server, we need to figure out how to implement the transport layer. The transport layer on the Client-side is responsible for sending the HTTP request and sending the response on the Server-side. We already know the Browser is the client in our web app, but we also need to consider the case both client and server could be Nodejs Server.</p>
<p>For browser client, we can use XHR to implement the transport layer, for NodeJs client, <code>http</code> module can do what XHR does. We will only use <code>POST</code> method, pack the name of the remote function and arguments required by those functions into the body of the request object.</p>
<pre><code class="language-TypeScript"><span class="hljs-comment">// Browser Client</span>
<span class="hljs-keyword">import</span> { RPCClientTransport, RPCProtocol, RPCSchemas } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../protocol&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCHttpClientTransport</span> <span class="hljs-title">implements</span> <span class="hljs-title">RPCClientTransport</span>&lt;<span class="hljs-title">any</span>&gt; </span>{
    <span class="hljs-keyword">private</span> _url:<span class="hljs-built_in">string</span>;
    <span class="hljs-keyword">private</span> _timeout:<span class="hljs-built_in">string</span>;

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">spec:{
        url:<span class="hljs-built_in">string</span>,
        timeout:<span class="hljs-built_in">number</span>,
    }</span>)</span> {
        <span class="hljs-built_in">this</span>._url = spec.url;
        <span class="hljs-built_in">this</span>._timeout = spec.timeout;
    }

    <span class="hljs-keyword">public</span> send&lt;Protocol <span class="hljs-keyword">extends</span> RPCProtocol&lt;<span class="hljs-built_in">any</span>&gt;&gt; (
        schemas:RPCSchemas&lt;Protocol&gt;,
        arg:RPCSchemas&lt;Protocol&gt;[<span class="hljs-string">&#x27;argSchema&#x27;</span>][<span class="hljs-string">&#x27;identity&#x27;</span>],
    ) {
        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
        xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-built_in">this</span>._url + <span class="hljs-string">&#x27;/&#x27;</span> + schemas.protocol.name, <span class="hljs-literal">true</span>);
        xhr.responseType = <span class="hljs-string">&#x27;&#x27;</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._timeout &lt; <span class="hljs-literal">Infinity</span> &amp;&amp; <span class="hljs-built_in">this</span>._timeout&gt;) {
            xhr.timeout = <span class="hljs-built_in">this</span>._timeout;
        }
        xhr.withCredentials = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">const</span> body = <span class="hljs-built_in">JSON</span>.stringify(schemas.argSchema.toJSON(arg));
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>&lt;RPCSchemas&lt;Protocol&gt;[<span class="hljs-string">&#x27;responseSchema&#x27;</span>][<span class="hljs-string">&#x27;identity&#x27;</span>]&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-keyword">let</span> completed = <span class="hljs-literal">false</span>;
            xhr.onreadystatechange = <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-keyword">if</span> (completed) {
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">const</span> readyState = xhr.readyState;
                <span class="hljs-keyword">if</span> (readyState === <span class="hljs-number">4</span>) {
                    completed = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">const</span> responseText = xhr.responseText;
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">let</span> json:<span class="hljs-built_in">any</span>;
                        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; responseText.length) {
                            json = <span class="hljs-built_in">JSON</span>.parse(responseText);
                        } <span class="hljs-keyword">else</span> {
                            json = {
                                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span>,
                                <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;empty response&#x27;</span>,
                            };
                        }
                        <span class="hljs-keyword">return</span> resolve(schemas.responseSchema.fromJSON(json));
                    } <span class="hljs-keyword">catch</span> (e) {
                        <span class="hljs-keyword">return</span> reject(e);
                    }
                };
            }
            xhr.onabort = <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-keyword">if</span> (completed) {
                    <span class="hljs-keyword">return</span>;
                }
                reject(<span class="hljs-string">`request aborted [mudb/rpc]`</span>);
            };
            xhr.onerror = <span class="hljs-function">() =&gt;</span> {
                <span class="hljs-keyword">if</span> (completed) {
                    <span class="hljs-keyword">return</span>;
                }
                reject(<span class="hljs-string">`error during request [mudb/rpc]`</span>);
            }
            xhr.send(body);
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;xhr has send the body&#x27;</span>, body);
        });
    }
}
</code></pre>
<p>As for the transport layer on server-side, it need to listen to the incoming request and handle it. The listen method is called by the RPC-server at its constructor, while the handler method is called in the Nodejs Route handler.</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCHttpServerTransport</span> </span>{
    ...
    ...
    <span class="hljs-keyword">public</span> listen&lt;Protocol <span class="hljs-keyword">extends</span> RPCProtocol&lt;<span class="hljs-built_in">any</span>&gt;&gt; (
        schemas:RPCSchemas&lt;Protocol&gt;,
        auth:<span class="hljs-function">(<span class="hljs-params">conn:RPCHttpConnection</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt;,
        recv:<span class="hljs-function">(<span class="hljs-params">conn:RPCHttpConnection, arg:RPCSchemas&lt;Protocol&gt;[<span class="hljs-string">&#x27;argSchema&#x27;</span>][<span class="hljs-string">&#x27;identity&#x27;</span>], response:RPCSchemas&lt;Protocol&gt;[<span class="hljs-string">&#x27;responseSchema&#x27;</span>][<span class="hljs-string">&#x27;identity&#x27;</span>]</span>) =&gt;</span> <span class="hljs-built_in">void</span>,
    ) {
        <span class="hljs-built_in">this</span>._handlers[schemas.protocol.name] = {
            schemas,
            auth,
            <span class="hljs-attr">recv</span>: &lt;<span class="hljs-built_in">any</span>&gt;recv,
        };
    }

    <span class="hljs-keyword">public</span> handler = <span class="hljs-keyword">async</span> (
        request:http.IncomingMessage,
        <span class="hljs-attr">response</span>:http.ServerResponse,
    ) =&gt; {
        <span class="hljs-keyword">const</span> method = request.method;
        <span class="hljs-keyword">if</span> (method !== <span class="hljs-string">&#x27;post&#x27;</span> &amp;&amp; method !== <span class="hljs-string">&#x27;POST&#x27;</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">const</span> url = request.url;
        <span class="hljs-keyword">if</span> (!url || !url.startsWith(<span class="hljs-built_in">this</span>._route)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">const</span> suffix = url.substr(<span class="hljs-built_in">this</span>._route.length);
        <span class="hljs-keyword">const</span> handler = <span class="hljs-built_in">this</span>._handlers[suffix];
        <span class="hljs-keyword">if</span> (!handler) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">const</span> ret = handler.schemas.responseSchema.alloc();
        <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">parseInt</span>(request.headers[<span class="hljs-string">&#x27;content-length&#x27;</span>] || <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">10</span>) || <span class="hljs-number">0</span>;
        ...
        ...
        <span class="hljs-comment">// receive and decode stream data</span>
        <span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> getRawBody(request, length);

        <span class="hljs-keyword">const</span> bodyStr = body.toString(<span class="hljs-string">&#x27;utf8&#x27;</span>);
        <span class="hljs-keyword">let</span> bodyJSON:<span class="hljs-built_in">any</span> = <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (bodyStr.length &gt; <span class="hljs-number">0</span>) {
            bodyJSON = <span class="hljs-built_in">JSON</span>.parse(bodyStr);
        }
        <span class="hljs-keyword">const</span> arg = handler.schemas.argSchema.fromJSON(bodyJSON);
        <span class="hljs-keyword">await</span> handler.recv(
            ...,
            arg,
            ret,
        );
        ...
        ...

        response.statusCode = ret.type === <span class="hljs-string">&#x27;success&#x27;</span> ? <span class="hljs-number">200</span> : <span class="hljs-number">400</span>;
        ...
        response.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json; charset=utf-8&#x27;</span>);
        response.end(<span class="hljs-built_in">JSON</span>.stringify(handler.schemas.responseSchema.toJSON(ret)));
        handler.schemas.responseSchema.free(ret);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<h3>RPC client and server</h3>
<p>For RPCClient, all it does is take the protocol object and transport instance to initiates invocations to procedures of the corresponding server.</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">import</span> { MuSchema } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mudb/src/schema&#x27;</span>;
<span class="hljs-keyword">import</span> { RPCProtocol, RPCSchemas, RPCClientTransport } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./protocol&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCClient</span>&lt;<span class="hljs-title">Protocol</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RPCProtocol</span>&lt;<span class="hljs-title">any</span>&gt;&gt; </span>{
    <span class="hljs-keyword">public</span> api:{
        [method <span class="hljs-keyword">in</span> keyof Protocol[<span class="hljs-string">&#x27;api&#x27;</span>]]:
            <span class="hljs-function">(<span class="hljs-params">arg:Protocol[<span class="hljs-string">&#x27;api&#x27;</span>][method][<span class="hljs-string">&#x27;arg&#x27;</span>][<span class="hljs-string">&#x27;identity&#x27;</span>]</span>) =&gt;</span>
                <span class="hljs-built_in">Promise</span>&lt;Protocol[<span class="hljs-string">&#x27;api&#x27;</span>][method][<span class="hljs-string">&#x27;ret&#x27;</span>][<span class="hljs-string">&#x27;identity&#x27;</span>]&gt;;
    };

    <span class="hljs-keyword">public</span> schemas:RPCSchemas&lt;Protocol&gt;;
    <span class="hljs-keyword">public</span> transport:RPCClientTransport&lt;Protocol&gt;;

    <span class="hljs-keyword">private</span> _handleResponse = <span class="hljs-function">(<span class="hljs-params">response:<span class="hljs-built_in">any</span></span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> { <span class="hljs-keyword">type</span>, data } = response;
        response.type = <span class="hljs-string">&#x27;error&#x27;</span>;
        response.data = <span class="hljs-string">&#x27;&#x27;</span>;
        <span class="hljs-built_in">this</span>.schemas.responseSchema.free(response);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;success&#x27;</span>) {
            <span class="hljs-keyword">return</span> data.data;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;RPCClient error&#x27;</span>, data);
            <span class="hljs-keyword">throw</span> data;
        }
    }

    <span class="hljs-keyword">private</span> _createRPC (method:keyof Protocol[<span class="hljs-string">&#x27;api&#x27;</span>]) {
        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">arg:MuSchema&lt;<span class="hljs-built_in">any</span>&gt;</span>) =&gt;</span> {
            <span class="hljs-keyword">const</span> rpc = <span class="hljs-built_in">this</span>.schemas.argSchema.alloc();
            rpc.type = method;
            rpc.data = arg;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;method:&#x27;</span>, method);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.transport.send(<span class="hljs-built_in">this</span>.schemas, rpc).then(
                <span class="hljs-built_in">this</span>._handleResponse,
                <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> {
                    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;RPCClient error&#x27;</span>, reason);
                },
            );
        };
    }

    <span class="hljs-title">constructor</span> (<span class="hljs-params">
        protocol:Protocol,
        transport:RPCClientTransport&lt;Protocol&gt;,
    </span>) {
        <span class="hljs-built_in">this</span>.schemas = <span class="hljs-keyword">new</span> RPCSchemas(protocol);
        <span class="hljs-built_in">this</span>.transport = transport;
        <span class="hljs-keyword">const</span> api = <span class="hljs-built_in">this</span>.api = &lt;<span class="hljs-built_in">any</span>&gt;{};
        <span class="hljs-keyword">const</span> methods = <span class="hljs-built_in">Object</span>.keys(protocol.api);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; methods.length; i++) {
            <span class="hljs-keyword">const</span> method = methods[i];
            api[method] = <span class="hljs-built_in">this</span>._createRPC(method);
        }
    }
}
</code></pre>
<p>In RPCServer, the actual remote function will be executed.</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RPCServer</span> </span>{
    <span class="hljs-keyword">public</span> schemas;
    <span class="hljs-keyword">public</span> transport;

     <span class="hljs-title">constructor</span> (<span class="hljs-params">spec:{
        protocol:Protocol,
        transport:RPCServerTransport&lt;Protocol, Connection&gt;,
        ...
        <span class="hljs-regexp">//</span> the handler contain the actual remote <span class="hljs-keyword">function</span> that client want to invoke
        handlers: {
            ...
        },
    }</span>) {
        <span class="hljs-keyword">const</span> schemas = <span class="hljs-built_in">this</span>.schemas = <span class="hljs-keyword">new</span> RPCSchemas(spec.protocol);
        <span class="hljs-built_in">this</span>.transport = spec.transport;
        <span class="hljs-built_in">this</span>.transport.listen(
            schemas,
            <span class="hljs-keyword">async</span> (conn, arg, response) =&gt; {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">const</span> method = &lt;<span class="hljs-built_in">any</span>&gt;arg.type;
                    <span class="hljs-keyword">const</span> handler = spec.handlers[method];
                    <span class="hljs-keyword">if</span> (!handler) {
                        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`invalid rpc method: <span class="hljs-subst">${method}</span>`</span>);
                        response.type = <span class="hljs-string">&#x27;error&#x27;</span>;
                        response.data = <span class="hljs-string">`invalid rpc method: <span class="hljs-subst">${method}</span>`</span>;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">const</span> retSchema = schemas.protocol.api[method].ret;
                        <span class="hljs-keyword">if</span> (handler.length === <span class="hljs-number">3</span>) {
                            <span class="hljs-keyword">const</span> ret = retSchema.alloc();
                            <span class="hljs-keyword">const</span> actualRet = <span class="hljs-keyword">await</span> handler(conn, arg.data, ret);
                            response.type = <span class="hljs-string">&#x27;success&#x27;</span>;
                            <span class="hljs-keyword">const</span> retInfo = response.data = schemas.retSchema.alloc();
                            retInfo.type = method;
                            <span class="hljs-keyword">if</span> (ret === actualRet) {
                                retInfo.data = ret;
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`warning, handler for <span class="hljs-subst">${method}</span> did not use storage for return type`</span>);
                                retSchema.free(ret);
                                retInfo.data = actualRet;
                            }
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-comment">// if user doesn&#x27;t take storage as an argument, then we just leak the response reference</span>
                            <span class="hljs-keyword">const</span> ret = <span class="hljs-keyword">await</span> handler(conn, arg.data, &lt;<span class="hljs-built_in">any</span>&gt;<span class="hljs-literal">undefined</span>);
                            response.type = <span class="hljs-string">&#x27;success&#x27;</span>;
                            <span class="hljs-keyword">const</span> retInfo = response.data = schemas.retSchema.alloc();
                            retInfo.type = method;
                            retInfo.data = retSchema.clone(ret);
                        }
                    }
                } <span class="hljs-keyword">catch</span> (e) {
                    response.type = <span class="hljs-string">&#x27;error&#x27;</span>;
                    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> &amp;&amp; e.message) {
                        response.data = e.message;
                    } <span class="hljs-keyword">else</span> {
                        response.data = e;
                    }
                }
            }
        );
    }
}
</code></pre>
<h2>Real Demo</h2>
<p>In the code of <a href="https://github.com/Francis-Tao-jinjin/web-app-setup/tree/rpc">this repo</a>,  go to the <code>/src/app/service</code>, you can see all the files related to RPC API, in the ‘calculator-protocol.ts’, the RPC calculator API is defined, in the calculator-server.ts, you can find the actual function that does the corresponding basic math calculation. In the <code>src/app/frontend/index.tsx</code>, the result of the calculator is obtained by calling the method in the RPCClient’s stub.</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FrontendUI</span> (<span class="hljs-params">props:{
    client:FrontendClient,
}</span>) </span>{
    ...
    ...
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            ...
            
            <span class="hljs-tag">&lt;<span class="hljs-name">Equation</span>
                <span class="hljs-attr">symbol</span>=<span class="hljs-string">{</span>&#x27;+&#x27;}
                <span class="hljs-attr">cal</span>=<span class="hljs-string">{(a:number,</span> <span class="hljs-attr">b:number</span>) =&gt;</span> {
                    // this function call return a promise object,
                    // which will return the response from the remote function on server

                    return props.client.rpc.caculator.api.add({a, b});
                }}
            &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Equation</span>&gt;</span>
            ...
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
}
</code></pre>
<p>As for the server of this demo, all you need to notice is where the  RPC Server’s transport gonna be. It need to be in the place that can handle the http request, typically, in the call back function of the http.createServer. In the <code>src/app/start-server.ts</code>, you can see I put that line inside the handler of defaultRoute</p>
<pre><code class="language-TypeScript"><span class="hljs-keyword">const</span> success = <span class="hljs-keyword">await</span> transport.handler(req, res);
</code></pre>
</div></article><div class="layout_backToHome__1vZsp"><a href="/">← Back to home</a></div><canvas></canvas></div><canvas id="glcanvas" width="1" height="1">Your browser doesn&#x27;t appear to support the HTML5 <code>&lt;canvas&gt;</code> element.</canvas></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"thinking-in-rpc","contentHtml":"\u003cdiv class='markdown'\u003e\u003c/div\u003e\n\u003ch1\u003eRemote Procedure Calls\u003c/h1\u003e\n\u003cp\u003eToday, whenever we think about how to implement client-server interaction, REST API is the pattern that always come first. Well, although it is tried and true, it is not the only pattern we can use. Before REST API become popular,  RPC has been used in various situations. Ever since the Nodejs take a place in a server-side language, adopt the RPC pattern for designing the client-server API may be a very interesting approach.\u003c/p\u003e\n\u003cp\u003eBefore we go further into this, we need to understand what is RPC, and why it is different from REST API as well as we shouldn’t use the rule of the REST to judge the RPC.\u003c/p\u003e\n\u003cp\u003eRemote Procedure Call (RPC) is a protocol that one program can use to request a service from a program localted in another computer on a network without having to understand the network’s details.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHowever, because we are dealing with an environment in which the processes are excuting on separate systems, we must use a \u003cstrong\u003emessage based communication scheme\u003c/strong\u003e to provide remote service.\u003c/li\u003e\n\u003cli\u003eThe RPC system hides the details that allow communication to take place by providing a stub on the client side.\u003c/li\u003e\n\u003cli\u003eTypically, a sparate stub exist for each separate remote procedure.\u003c/li\u003e\n\u003cli\u003eWhen the client invokes a remote procedure, the RPC system call the approriate stub, passing it the parameters provided to the remote procudure. This stub locates the port ont the server and marshals the parameters.\u003c/li\u003e\n\u003cli\u003eParameter marshalling involves packaging the parameters into a form that can be transmitted over a network.\u003c/li\u003e\n\u003cli\u003eThe stub then transmits a message to the server using message passing.\u003c/li\u003e\n\u003cli\u003eA similar stub on the server side receives this message and invokes the procedure on the server.\u003c/li\u003e\n\u003cli\u003eIf necessary, return values are passed back to the client using the same technique.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe REST API, in contrast, models the various entities within the problem domain as resources, and uses HTTP verbs to represent transactions against these resources - POST to create, PUT to update, and GET to read. All of these verbs, invoked on the same URL, provide different functionality. Common HTTP return codes are used to convey status of the requests.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eREST must be stateless: not persisting sessions between requests.\u003c/li\u003e\n\u003cli\u003eResponses should declare cacheablility: helps your API scale if clients respect the rules.\u003c/li\u003e\n\u003cli\u003eREST focuses on uniformity: if you’re using HTTP you should utilize HTTP features whenever possible, instead of inventing conventions.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn short, RPC treats the client’s request to the server as a call to a remote function while REST API see it as an acquisition of resources.\u003c/p\u003e\n\u003ch2\u003eRemote and Async\u003c/h2\u003e\n\u003cp\u003eThis is the moment when JavaScript become really handy. The ability of handling async function is simply inside JavaScript’s veins. While in RPC, what we need to achieve just a little bit different, that we need to hide all the detail of making http request and turn the remote function invoke looks like call a local async function.\u003c/p\u003e\n\u003ch3\u003eDesign the architecture\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eprotocol\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA protocol is the description of the api between a client and a server. You can define multiple different protocols in your application for different functionalities, with equal number of client-server pairs each dedicated to one of the protocols.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eclient/server\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAll communications are initiated by client. Client calls, server executes. Client can only communicate with server through the api defined by the protocol, which means they both need to “understand” the same protocol.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003etransport\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eClient and server take care of invocation and execution, while transport takes care of message passing. Transports are protocol-agnostic. It means different servers can share the same server transport. Similarly, different clients can share one client transport.\u003c/p\u003e\n\u003cp\u003eOk, finished talking, let’s try to build a real RPC library, we also gonna write a simple demo program to show how to use this library. You can checkout out \u003ca href=\"https://github.com/Francis-Tao-jinjin/web-app-setup/tree/rpc\"\u003ethis repo\u003c/a\u003e to see the final code. The project is setup base on the \u003ca href=\"https://francis-tao-jinjin.github.io/posts/web-app-setup-1\"\u003eWebApp setup from scratch\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eProtocol\u003c/h3\u003e\n\u003cp\u003eIn this project, we are using \u003cem\u003emudb/muSchema\u003c/em\u003e and \u003cem\u003eTypeScript\u003c/em\u003e. First, we gonna define the type/interface for the RPC protocol, which contain all the api information. The api data could be as simple as a key value table.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e RPCTableEntry\u0026lt;ArgsSchema \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e MuSchema\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;, ReturnSchema \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e MuSchema\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;\u0026gt; = {\n    \u003cspan class=\"hljs-attr\"\u003earg\u003c/span\u003e:ArgsSchema;\n    reg:ReturnSchema;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e RPCTable = {\n    [method:\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e]:RPCTableEntry\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e RPCProtocol\u0026lt;AnyRPCTable \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e RPCTable\u0026gt; = {\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e:\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n    api:AnyRPCTable;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor each protocol object, it will need a unique name and an API object which list all the basic info of the remote function. The unique protocol name, in this case, can be seen as something like a namespace and will also be used in URL path.\u003c/p\u003e\n\u003cp\u003eHere is code show how to create a actual protocol object accroding to the type definitation.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { MuUTF8, MuStruct, MuFloat64, MuVoid } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;mudb/src/schema\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e CaculatorRPCSchema = {\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;caculator-service\u0026#x27;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eapi\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003ehello\u003c/span\u003e: {\n            \u003cspan class=\"hljs-attr\"\u003earg\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuVoid(),\n            \u003cspan class=\"hljs-attr\"\u003eret\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuUTF8(),\n        },\n        \u003cspan class=\"hljs-attr\"\u003eadd\u003c/span\u003e: {\n            \u003cspan class=\"hljs-attr\"\u003earg\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuStruct({\n                \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuFloat64(),\n                \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuFloat64(),\n            }),\n            \u003cspan class=\"hljs-attr\"\u003eret\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuFloat64(),\n        },\n        ...\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter we have define the protocol, we need a helper class that let both server and client understand the protocol:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRPCSchemas\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003eProtocol\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRPCProtocol\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003eany\u003c/span\u003e\u0026gt;\u0026gt; \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e errorSchema = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuUTF8();\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e tokenSchema = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Muvarint();\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e argSchema:MuUnion\u0026lt;{\n        [key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e keyof Protocol[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;api\u0026#x27;\u003c/span\u003e]]:Protocol[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;api\u0026#x27;\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;arg\u0026#x27;\u003c/span\u003e];\n    }\u0026gt;;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e retSchema:MuUnion\u0026lt;{\n        [key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e keyof Protocol[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;api\u0026#x27;\u003c/span\u003e]]:Protocol[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;api\u0026#x27;\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;ret\u0026#x27;\u003c/span\u003e];\n    }\u0026gt;;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e responseSchema:MuUnion\u0026lt;{\n        \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e:RPCSchemas\u0026lt;Protocol\u0026gt;[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;retSchema\u0026#x27;\u003c/span\u003e];\n        error:RPCSchemas\u0026lt;Protocol\u0026gt;[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;errorSchema\u0026#x27;\u003c/span\u003e];\n    }\u0026gt;;\n\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e protocol:Protocol\u003c/span\u003e)\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e argTable:\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e = {};\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e retTable:\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e = {};\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e methods = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.keys(protocol.api);\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; methods.length; i++\u0026gt;) {\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e m = methods[i];\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e s = protocol.api[m];\n            argTable[m] = s.arg;\n            retTable[m] = s.ret;\n        }\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.argSchema = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuUnion(argTable);\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.retSchema = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuUnion(retTable);\n\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.responseSchema = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e MuUnion({\n            \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.retSchema,\n            \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.errorSchema,\n        });\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eTransport\u003c/h3\u003e\n\u003cp\u003eBefore we start implementing the stubs for both client and server, we need to figure out how to implement the transport layer. The transport layer on the Client-side is responsible for sending the HTTP request and sending the response on the Server-side. We already know the Browser is the client in our web app, but we also need to consider the case both client and server could be Nodejs Server.\u003c/p\u003e\n\u003cp\u003eFor browser client, we can use XHR to implement the transport layer, for NodeJs client, \u003ccode\u003ehttp\u003c/code\u003e module can do what XHR does. We will only use \u003ccode\u003ePOST\u003c/code\u003e method, pack the name of the remote function and arguments required by those functions into the body of the request object.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Browser Client\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { RPCClientTransport, RPCProtocol, RPCSchemas } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../protocol\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRPCHttpClientTransport\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRPCClientTransport\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003eany\u003c/span\u003e\u0026gt; \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e _url:\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e _timeout:\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003espec:{\n        url:\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e,\n        timeout:\u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e,\n    }\u003c/span\u003e)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._url = spec.url;\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._timeout = spec.timeout;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e send\u0026lt;Protocol \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e RPCProtocol\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;\u0026gt; (\n        schemas:RPCSchemas\u0026lt;Protocol\u0026gt;,\n        arg:RPCSchemas\u0026lt;Protocol\u0026gt;[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;argSchema\u0026#x27;\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;identity\u0026#x27;\u003c/span\u003e],\n    ) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e XMLHttpRequest();\n        xhr.open(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;POST\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._url + \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/\u0026#x27;\u003c/span\u003e + schemas.protocol.name, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n        xhr.responseType = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._timeout \u0026lt; \u003cspan class=\"hljs-literal\"\u003eInfinity\u003c/span\u003e \u0026amp;\u0026amp; \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._timeout\u0026gt;) {\n            xhr.timeout = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._timeout;\n        }\n        xhr.withCredentials = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e body = \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(schemas.argSchema.toJSON(arg));\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;RPCSchemas\u0026lt;Protocol\u0026gt;[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;responseSchema\u0026#x27;\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;identity\u0026#x27;\u003c/span\u003e]\u0026gt;(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve, reject\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e completed = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n            xhr.onreadystatechange = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (completed) {\n                    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n                }\n                \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readyState = xhr.readyState;\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (readyState === \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) {\n                    completed = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n                    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e responseText = xhr.responseText;\n                    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n                        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e json:\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e;\n                        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026lt; responseText.length) {\n                            json = \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(responseText);\n                        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                            json = {\n                                \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;error\u0026#x27;\u003c/span\u003e,\n                                \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;empty response\u0026#x27;\u003c/span\u003e,\n                            };\n                        }\n                        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e resolve(schemas.responseSchema.fromJSON(json));\n                    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n                        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e reject(e);\n                    }\n                };\n            }\n            xhr.onabort = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (completed) {\n                    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n                }\n                reject(\u003cspan class=\"hljs-string\"\u003e`request aborted [mudb/rpc]`\u003c/span\u003e);\n            };\n            xhr.onerror = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (completed) {\n                    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n                }\n                reject(\u003cspan class=\"hljs-string\"\u003e`error during request [mudb/rpc]`\u003c/span\u003e);\n            }\n            xhr.send(body);\n            \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;xhr has send the body\u0026#x27;\u003c/span\u003e, body);\n        });\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs for the transport layer on server-side, it need to listen to the incoming request and handle it. The listen method is called by the RPC-server at its constructor, while the handler method is called in the Nodejs Route handler.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRPCHttpServerTransport\u003c/span\u003e \u003c/span\u003e{\n    ...\n    ...\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e listen\u0026lt;Protocol \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e RPCProtocol\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;\u0026gt; (\n        schemas:RPCSchemas\u0026lt;Protocol\u0026gt;,\n        auth:\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econn:RPCHttpConnection\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eboolean\u003c/span\u003e\u0026gt;,\n        recv:\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econn:RPCHttpConnection, arg:RPCSchemas\u0026lt;Protocol\u0026gt;[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;argSchema\u0026#x27;\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;identity\u0026#x27;\u003c/span\u003e], response:RPCSchemas\u0026lt;Protocol\u0026gt;[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;responseSchema\u0026#x27;\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;identity\u0026#x27;\u003c/span\u003e]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e,\n    ) {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._handlers[schemas.protocol.name] = {\n            schemas,\n            auth,\n            \u003cspan class=\"hljs-attr\"\u003erecv\u003c/span\u003e: \u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;recv,\n        };\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e handler = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\n        request:http.IncomingMessage,\n        \u003cspan class=\"hljs-attr\"\u003eresponse\u003c/span\u003e:http.ServerResponse,\n    ) =\u0026gt; {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e method = request.method;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (method !== \u003cspan class=\"hljs-string\"\u003e\u0026#x27;post\u0026#x27;\u003c/span\u003e \u0026amp;\u0026amp; method !== \u003cspan class=\"hljs-string\"\u003e\u0026#x27;POST\u0026#x27;\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e url = request.url;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!url || !url.startsWith(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._route)) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e suffix = url.substr(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._route.length);\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handler = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._handlers[suffix];\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!handler) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ret = handler.schemas.responseSchema.alloc();\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e length = \u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(request.headers[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;content-length\u0026#x27;\u003c/span\u003e] || \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e) || \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n        ...\n        ...\n        \u003cspan class=\"hljs-comment\"\u003e// receive and decode stream data\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e body = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e getRawBody(request, length);\n\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bodyStr = body.toString(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;utf8\u0026#x27;\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e bodyJSON:\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (bodyStr.length \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n            bodyJSON = \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(bodyStr);\n        }\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arg = handler.schemas.argSchema.fromJSON(bodyJSON);\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e handler.recv(\n            ...,\n            arg,\n            ret,\n        );\n        ...\n        ...\n\n        response.statusCode = ret.type === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;success\u0026#x27;\u003c/span\u003e ? \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e;\n        ...\n        response.setHeader(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Content-Type\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;application/json; charset=utf-8\u0026#x27;\u003c/span\u003e);\n        response.end(\u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(handler.schemas.responseSchema.toJSON(ret)));\n        handler.schemas.responseSchema.free(ret);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eRPC client and server\u003c/h3\u003e\n\u003cp\u003eFor RPCClient, all it does is take the protocol object and transport instance to initiates invocations to procedures of the corresponding server.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { MuSchema } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;mudb/src/schema\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { RPCProtocol, RPCSchemas, RPCClientTransport } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./protocol\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRPCClient\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003eProtocol\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRPCProtocol\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-title\"\u003eany\u003c/span\u003e\u0026gt;\u0026gt; \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e api:{\n        [method \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e keyof Protocol[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;api\u0026#x27;\u003c/span\u003e]]:\n            \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earg:Protocol[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;api\u0026#x27;\u003c/span\u003e][method][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;arg\u0026#x27;\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;identity\u0026#x27;\u003c/span\u003e]\u003c/span\u003e) =\u0026gt;\u003c/span\u003e\n                \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026lt;Protocol[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;api\u0026#x27;\u003c/span\u003e][method][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;ret\u0026#x27;\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\u0026#x27;identity\u0026#x27;\u003c/span\u003e]\u0026gt;;\n    };\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e schemas:RPCSchemas\u0026lt;Protocol\u0026gt;;\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e transport:RPCClientTransport\u0026lt;Protocol\u0026gt;;\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e _handleResponse = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse:\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e, data } = response;\n        response.type = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;error\u0026#x27;\u003c/span\u003e;\n        response.data = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e;\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.schemas.responseSchema.free(response);\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;success\u0026#x27;\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data.data;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;RPCClient error\u0026#x27;\u003c/span\u003e, data);\n            \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e data;\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e _createRPC (method:keyof Protocol[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;api\u0026#x27;\u003c/span\u003e]) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earg:MuSchema\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rpc = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.schemas.argSchema.alloc();\n            rpc.type = method;\n            rpc.data = arg;\n            \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;method:\u0026#x27;\u003c/span\u003e, method);\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.transport.send(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.schemas, rpc).then(\n                \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._handleResponse,\n                \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereason\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n                    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;RPCClient error\u0026#x27;\u003c/span\u003e, reason);\n                },\n            );\n        };\n    }\n\n    \u003cspan class=\"hljs-title\"\u003econstructor\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\n        protocol:Protocol,\n        transport:RPCClientTransport\u0026lt;Protocol\u0026gt;,\n    \u003c/span\u003e) {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.schemas = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RPCSchemas(protocol);\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.transport = transport;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e api = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.api = \u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;{};\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e methods = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.keys(protocol.api);\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; methods.length; i++) {\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e method = methods[i];\n            api[method] = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e._createRPC(method);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn RPCServer, the actual remote function will be executed.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRPCServer\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e schemas;\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e transport;\n\n     \u003cspan class=\"hljs-title\"\u003econstructor\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003espec:{\n        protocol:Protocol,\n        transport:RPCServerTransport\u0026lt;Protocol, Connection\u0026gt;,\n        ...\n        \u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e the handler contain the actual remote \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e that client want to invoke\n        handlers: {\n            ...\n        },\n    }\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e schemas = \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.schemas = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e RPCSchemas(spec.protocol);\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.transport = spec.transport;\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.transport.listen(\n            schemas,\n            \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (conn, arg, response) =\u0026gt; {\n                \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n                    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e method = \u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;arg.type;\n                    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handler = spec.handlers[method];\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!handler) {\n                        \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(\u003cspan class=\"hljs-string\"\u003e`invalid rpc method: \u003cspan class=\"hljs-subst\"\u003e${method}\u003c/span\u003e`\u003c/span\u003e);\n                        response.type = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;error\u0026#x27;\u003c/span\u003e;\n                        response.data = \u003cspan class=\"hljs-string\"\u003e`invalid rpc method: \u003cspan class=\"hljs-subst\"\u003e${method}\u003c/span\u003e`\u003c/span\u003e;\n                    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e retSchema = schemas.protocol.api[method].ret;\n                        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (handler.length === \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) {\n                            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ret = retSchema.alloc();\n                            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e actualRet = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e handler(conn, arg.data, ret);\n                            response.type = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;success\u0026#x27;\u003c/span\u003e;\n                            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e retInfo = response.data = schemas.retSchema.alloc();\n                            retInfo.type = method;\n                            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ret === actualRet) {\n                                retInfo.data = ret;\n                            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                                \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-string\"\u003e`warning, handler for \u003cspan class=\"hljs-subst\"\u003e${method}\u003c/span\u003e did not use storage for return type`\u003c/span\u003e);\n                                retSchema.free(ret);\n                                retInfo.data = actualRet;\n                            }\n                        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                            \u003cspan class=\"hljs-comment\"\u003e// if user doesn\u0026#x27;t take storage as an argument, then we just leak the response reference\u003c/span\u003e\n                            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ret = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e handler(conn, arg.data, \u0026lt;\u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e\u0026gt;\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e);\n                            response.type = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;success\u0026#x27;\u003c/span\u003e;\n                            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e retInfo = response.data = schemas.retSchema.alloc();\n                            retInfo.type = method;\n                            retInfo.data = retSchema.clone(ret);\n                        }\n                    }\n                } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n                    response.type = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;error\u0026#x27;\u003c/span\u003e;\n                    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (e \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e \u0026amp;\u0026amp; e.message) {\n                        response.data = e.message;\n                    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                        response.data = e;\n                    }\n                }\n            }\n        );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eReal Demo\u003c/h2\u003e\n\u003cp\u003eIn the code of \u003ca href=\"https://github.com/Francis-Tao-jinjin/web-app-setup/tree/rpc\"\u003ethis repo\u003c/a\u003e,  go to the \u003ccode\u003e/src/app/service\u003c/code\u003e, you can see all the files related to RPC API, in the ‘calculator-protocol.ts’, the RPC calculator API is defined, in the calculator-server.ts, you can find the actual function that does the corresponding basic math calculation. In the \u003ccode\u003esrc/app/frontend/index.tsx\u003c/code\u003e, the result of the calculator is obtained by calling the method in the RPCClient’s stub.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eFrontendUI\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eprops:{\n    client:FrontendClient,\n}\u003c/span\u003e) \u003c/span\u003e{\n    ...\n    ...\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n        \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n            ...\n            \n            \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eEquation\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003esymbol\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\u0026#x27;+\u0026#x27;}\n                \u003cspan class=\"hljs-attr\"\u003ecal\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(a:number,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eb:number\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n                    // this function call return a promise object,\n                    // which will return the response from the remote function on server\n\n                    return props.client.rpc.caculator.api.add({a, b});\n                }}\n            \u0026gt;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eEquation\u003c/span\u003e\u0026gt;\u003c/span\u003e\n            ...\n        \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n    );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs for the server of this demo, all you need to notice is where the  RPC Server’s transport gonna be. It need to be in the place that can handle the http request, typically, in the call back function of the http.createServer. In the \u003ccode\u003esrc/app/start-server.ts\u003c/code\u003e, you can see I put that line inside the handler of defaultRoute\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-TypeScript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e success = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e transport.handler(req, res);\n\u003c/code\u003e\u003c/pre\u003e\n","title":"Thinking In RPC","pic":"/images/thinking-in-rpc/rpc.png","keyword":"Remote Procedure Calls, NodeJs","description":"Ever since the Nodejs take a place in a server-side language, adopt the RPC pattern for designing the client-server API may be a very interesting approach.","date":"2019-08-01"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"thinking-in-rpc"},"buildId":"fKjDvqZa9A_kBlPN-TeyU","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-feb8a7604fa7fce626b2.js"></script><script src="/_next/static/chunks/main-b6d312587e2afb5b7e03.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.9d524150d48315f49e80.js" async=""></script><script src="/_next/static/chunks/7a55d4b5.210d3c80a2b0e2401248.js" async=""></script><script src="/_next/static/chunks/commons.0a849237534e67e84d9a.js" async=""></script><script src="/_next/static/chunks/pages/_app-929cb4bd00d30619cb94.js" async=""></script><script src="/_next/static/chunks/df27990eef8845831ef4a3353c0adb327953b68f.6ebe35bf6c0aadc1eb95.js" async=""></script><script src="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a80097bea88316e5b19e.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-67fc6c234c356062955a.js" async=""></script><script src="/_next/static/fKjDvqZa9A_kBlPN-TeyU/_buildManifest.js" async=""></script><script src="/_next/static/fKjDvqZa9A_kBlPN-TeyU/_ssgManifest.js" async=""></script></body></html>
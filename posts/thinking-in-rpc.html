<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Francis Tao-Jinjin Next.js GitHub Pages"/><meta property="og:image" content="https://og-image.now.sh/Francis%20Tao-Jinjin%20Next.js%20GitHub%20Pages.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Francis Tao-Jinjin Next.js GitHub Pages"/><meta name="teitter:card" content="summary_large_image"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css"/><title>Thinking In RPC</title><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/525ade0da8ac601406c9.css" as="style"/><link rel="stylesheet" href="/_next/static/css/525ade0da8ac601406c9.css" data-n-g=""/><link rel="preload" href="/_next/static/css/7c37ee6f4b99f4530db0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7c37ee6f4b99f4530db0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/ca491a2f2dad37bc344d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ca491a2f2dad37bc344d.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-fcbdb94e906b93a1f560.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9d524150d48315f49e80.js" as="script"/><link rel="preload" href="/_next/static/chunks/7a55d4b5.210d3c80a2b0e2401248.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.ff0a5790a80e83d7223b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-5d53db12a2c7a352dba7.js" as="script"/><link rel="preload" href="/_next/static/chunks/df27990eef8845831ef4a3353c0adb327953b68f.b37cb412c978ebbef724.js" as="script"/><link rel="preload" href="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a80097bea88316e5b19e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-dd642f1262e5265a6db6.js" as="script"/></head><body><div id="__next"><div class="layout_container__2t4v2"><header class="layout_header__2rhWq"><a href="/"><img src="/images/profile.png" class="layout_headerImage__2h5On utils_borderCircle__13qdJ" alt="Francis Tao"/></a><h2 class="utils_headingLg__de7p0"><a class="utils_colorInherit__3Gudf" href="/">Francis Tao</a></h2></header><article><h1 class="utils_headingXl__1XecN">Thinking In RPC</h1><div class="utils_lightText__12Ckm"><time dateTime="2019-05-01">May 1, 2019</time></div><div><div class='markdown'></div>
<p>Today, whenever we thinking about how to implement client-server interaction, REST API is the pattern that always come first. Well, although it is tried and true, it is not the only pattern we can use. Before REST API become popular,  RPC has been used in various situations. Ever since the Nodejs take a place in a server-side language, adopt the RPC pattern for designing the client-server API may be a very interesting approach.</p>
<p>Before we go further into this, we need to understand what is RPC, and why it is different from REST API as well as we shouldn’t use the rule of the REST to judge the RPC.</p>
<p>Remote Procedure Call (RPC) is a protocol that one program can use to request a service from a program localted in another computer on a network without having to understand the network’s details.</p>
<ul>
<li>However, because we are dealing with an environment in which the processes are excuting on separate systems, we must use a <strong>message based communication scheme</strong> to provide remote service.</li>
<li>The RPC system hides the details that allow communication to take place by providing a stub on the client side.</li>
<li>Typically, a sparate stub exist for each separate remote procedure.</li>
<li>When the client invokes a remote procedure, the RPC system call the approriate stub, passing it the parameters provided to the remote procudure. This stub locates the port ont the server and marshals the parameters.</li>
<li>Parameter marshalling involves packaging the parameters into a form that can be transmitted over a network.</li>
<li>The stub then transmits a message to the server using message passing.</li>
<li>A similar stub on the server side receives this message and invokes the procedure on the server.</li>
<li>If necessary, return values are passed back to the client using the same technique.</li>
</ul>
<p>The REST API, in contrast, models the various entities within the problem domain as resources, and uses HTTP verbs to represent transactions against these resources - POST to create, PUT to update, and GET to read. All of these verbs, invoked on the same URL, provide different functionality. Common HTTP return codes are used to convey status of the requests.</p>
<ul>
<li>REST must be stateless: not persisting sessions between requests.</li>
<li>Responses should declare cacheablility: helps your API scale if clients respect the rules.</li>
<li>REST focuses on uniformity: if you’re using HTTP you should utilize HTTP features whenever possible, instead of inventing conventions.</li>
</ul>
</div></article><div class="layout_backToHome__1vZsp"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"thinking-in-rpc","contentHtml":"\u003cdiv class='markdown'\u003e\u003c/div\u003e\n\u003cp\u003eToday, whenever we thinking about how to implement client-server interaction, REST API is the pattern that always come first. Well, although it is tried and true, it is not the only pattern we can use. Before REST API become popular,  RPC has been used in various situations. Ever since the Nodejs take a place in a server-side language, adopt the RPC pattern for designing the client-server API may be a very interesting approach.\u003c/p\u003e\n\u003cp\u003eBefore we go further into this, we need to understand what is RPC, and why it is different from REST API as well as we shouldn’t use the rule of the REST to judge the RPC.\u003c/p\u003e\n\u003cp\u003eRemote Procedure Call (RPC) is a protocol that one program can use to request a service from a program localted in another computer on a network without having to understand the network’s details.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHowever, because we are dealing with an environment in which the processes are excuting on separate systems, we must use a \u003cstrong\u003emessage based communication scheme\u003c/strong\u003e to provide remote service.\u003c/li\u003e\n\u003cli\u003eThe RPC system hides the details that allow communication to take place by providing a stub on the client side.\u003c/li\u003e\n\u003cli\u003eTypically, a sparate stub exist for each separate remote procedure.\u003c/li\u003e\n\u003cli\u003eWhen the client invokes a remote procedure, the RPC system call the approriate stub, passing it the parameters provided to the remote procudure. This stub locates the port ont the server and marshals the parameters.\u003c/li\u003e\n\u003cli\u003eParameter marshalling involves packaging the parameters into a form that can be transmitted over a network.\u003c/li\u003e\n\u003cli\u003eThe stub then transmits a message to the server using message passing.\u003c/li\u003e\n\u003cli\u003eA similar stub on the server side receives this message and invokes the procedure on the server.\u003c/li\u003e\n\u003cli\u003eIf necessary, return values are passed back to the client using the same technique.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe REST API, in contrast, models the various entities within the problem domain as resources, and uses HTTP verbs to represent transactions against these resources - POST to create, PUT to update, and GET to read. All of these verbs, invoked on the same URL, provide different functionality. Common HTTP return codes are used to convey status of the requests.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eREST must be stateless: not persisting sessions between requests.\u003c/li\u003e\n\u003cli\u003eResponses should declare cacheablility: helps your API scale if clients respect the rules.\u003c/li\u003e\n\u003cli\u003eREST focuses on uniformity: if you’re using HTTP you should utilize HTTP features whenever possible, instead of inventing conventions.\u003c/li\u003e\n\u003c/ul\u003e\n","title":"Thinking In RPC","pic":"/images/thinking-in-rpc/rpc.png","keyword":"Remote Procedure Calls, NodeJs","description":"Ever since the Nodejs take a place in a server-side language, adopt the RPC pattern for designing the client-server API may be a very interesting approach.","date":"2019-05-01"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"thinking-in-rpc"},"buildId":"iKjY_zXKM7MmXYbJPJTKf","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-feb8a7604fa7fce626b2.js"></script><script src="/_next/static/chunks/main-fcbdb94e906b93a1f560.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.9d524150d48315f49e80.js" async=""></script><script src="/_next/static/chunks/7a55d4b5.210d3c80a2b0e2401248.js" async=""></script><script src="/_next/static/chunks/commons.ff0a5790a80e83d7223b.js" async=""></script><script src="/_next/static/chunks/pages/_app-5d53db12a2c7a352dba7.js" async=""></script><script src="/_next/static/chunks/df27990eef8845831ef4a3353c0adb327953b68f.b37cb412c978ebbef724.js" async=""></script><script src="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.a80097bea88316e5b19e.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-dd642f1262e5265a6db6.js" async=""></script><script src="/_next/static/iKjY_zXKM7MmXYbJPJTKf/_buildManifest.js" async=""></script><script src="/_next/static/iKjY_zXKM7MmXYbJPJTKf/_ssgManifest.js" async=""></script></body></html>
{"pageProps":{"postData":{"id":"audio-adjust-tool","contentHtml":"<h1 class=\"text-3xl font-medium mb-2 mt-3\">Audio Adjustment Tool Of Box3 Game Editor</h1>\n<div class='m-5'></div>\n<img src=\"/images/audio-adjust/audio-upload.gif\" alt=\"audio upload\" style=\"width:400px; margin:auto\"/>\n<div class='m-5'></div>\n<p>This is a tool for uploading and simply processing audio in the box3 game editor. I have written a component specifically for this functionality, which in addition to React, will also involve the WebAudio API and canvas 2d.</p>\n<div class='m-5'></div>\nThe main functions of this component include: playing and pausing audio, cropping audio, and providing convenient UI controls and visual feedback for these functions.\n<div class='m-5'></div>\nFor those who are not familiar with WebAudio API. All you need to know is the 'Audio' we talk about is actually a kind of data buffer that we call <code class='il'>AudioBuffer</code>. Whether it's playing or cropping or even adding sound effects, it's all about the buffer in the end.\n<div class='m-5'></div>\nTo play an audioBuffer, we need to create an <code class='il'>AudioBufferSourceNode</code>, be noticed, an AudioBufferSourceNode can only be start and stop once. Otherwise, your javascript gonna throw error.\n<div class='m-5'></div>\nNow we clear that we need to implement a class to handle all the operations to the audioBuffer and a React component to handle UI interaction.\n<div class='m-5'></div>\nWe can call that  class 'AudioPlayer', it need to support basic <code class='il'>play</code> and <code class='il'>stop</code>, beside, user may want to start playback from any position of the audio, and the selected interval should support loop playback.\n<div class='preCodeBlock'></div>\n<pre><code class=\"language-javascript\">class AudioPlayer {\n    private _state = 'stopped';\n    private _offset = 0;\n    private _startTime = 0;\n    private _finished = false;\n    constructor(\n        private audioBuffer:AudioBuffer,\n        private audioContext:AudioContext) {\n    }\n\n    private _loopStart = 0;\n    public set loopStart(value:number) {\n        ...\n    }\n\n    private _loopEnd = Infinity;\n    public set loopEnd(value:number) {\n        ...\n    }\n\n    private _loop = false;\n    public set loop(flag:boolean) {\n        this._loop = flag;\n    }\n\n    private _source:AudioBufferSourceNode|null = null;\n\n    private now() {\n        return this.audioContext.currentTime;\n    }\n\n    public start(startTime?:number, offset?:number) {\n        ...\n    }\n\n    public get state() {\n        return this._state;\n    }\n\n    public get finished() {\n        return this._finished;\n    }\n\n    public stop(time?:number) {\n        ...\n    }\n\n    public seek(offset:number, time:number) {\n        ...\n    }\n}\n</code></pre>\n<p>The start method receive two optional param, <code class='il'>startTime</code> refer to the global time of 'AudioContex', if you want to start at the time you call the method, just pass  <code class='il'>audioContext.currentTime</code> to it. <code class='il'>offset</code> refer to the duration of the audio. If an audio is 1.5s long and you wang to start playback from the 0.5s, then the <code class='il'>offset</code> is 0.5 .</p>\n<p>Here is how I implement the <code class='il'>start</code> and <code class='il'>stop</code>method:</p>\n<div class='preCodeBlock'></div>\n<pre><code class=\"language-javascript\">public start(startTime?:number, offset?:number) {\n    if (startTime === undefined) {\n        startTime = this.now();\n    }\n    if (offset === undefined) {\n        if (this._loop) {\n            offset = this._loopStart;\n        } else {\n            offset = 0;\n        }\n    }\n    this._source = this.audioContext.createBufferSource();\n    this._source.connect(this.audioContext.destination);\n    this._source.buffer = this.audioBuffer;\n    this._source.onended = () => {\n        const now = this.now();\n        if (!this._loop) {\n            const passTime = (now - this._startTime + this._offset);\n            if (passTime >= this.audioBuffer.duration) {\n                this._finished = true;\n            } else if (this.audioBuffer.duration - passTime >= 0 &#x26;&#x26;\n                        this.audioBuffer.duration - passTime &#x3C;= 1e-4) {\n                this._finished = true;\n            }\n        }\n    };\n    this._source.loop = this._loop;\n    this._source.loopStart = this._loopStart;\n    this._source.loopEnd = Math.min(this._loopEnd, this.audioBuffer.duration);\n    this._state = 'started';\n    this._source.start(startTime, offset);\n    this._offset = offset;\n    this._startTime = startTime;\n}\n\npublic stop(time?:number) {\n    if (time === undefined) {\n        time = this.now();\n    }\n    if (this._source) {\n        this._source.stop(time);\n        this._source.disconnect();\n        this._state = 'stopped';\n    }\n}\n</code></pre>\n<p>As for the <code class='il'>seek</code>, you can simply call <code class='il'>stop</code> then call <code class='il'>start</code> in it.</p>\n<h2 class=\"text-xl font-medium mb-2 mt-3\">Drawing the Waveform</h2>\n<p>Drawing the waveform of audiobuffer is fairly easy. You don't need to install another package to do it, all you need to do is some simple calculation. Many people like to install a bunch of extra modules to solve a small problem, but I prefer not to install them if I don't need to. This allows you to keep your code light weight, and you can learn a lot of new things in the process.</p>\n<div class='preCodeBlock'></div>\n<pre><code class=\"language-javascript\">function computeWaveForm(container:HTMLDivElement, buffer:AudioBuffer) {\n    const peaks:number[] = [];\n    const chann0 = (buffer.getChannelData(0) as ArrayBuffer);\n    // const sampleSize = props.buffer.length / props.waveformWidth;\n    const sampleSize = buffer.length / container.clientWidth;\n    const sampleStep = ~~(sampleSize / 10) || 1;\n\n    for (let i = 0; i &#x3C; container.clientWidth; i++) {\n    // for (let i = 0; i &#x3C; props.waveformWidth; i++) {\n        const start = ~~(i * sampleSize);\n        const end = ~~(start + sampleSize);\n        let topCount = 0;\n        let bottomCount = 0;\n        let bottom = 0;\n        let top = 0;\n        for (var j = start; j &#x3C; end; j += sampleStep) {\n            const value = chann0[j];\n            if (value > 0) {\n                bottom += value * value;\n                bottomCount++;\n            }\n            if (value &#x3C; 0) {\n                top += value * value;\n                topCount++;\n            }\n        }\n        peaks[2 * i] = Math.sqrt(bottom / bottomCount) * 256;\n        peaks[2 * i + 1] = -Math.sqrt(top / topCount) * 256;\n    }\n    return peaks;\n}\n\nfunction drawWaveForm(canvasEle:HTMLCanvasElement, container:HTMLDivElement, peaks:number[], waveformHeight:number) {\n    if (canvasEle &#x26;&#x26; container) {\n        const cvsCtx = canvasEle.getContext('2d');\n        if (cvsCtx) {\n            let dirty = false;\n            if (canvasEle.height !== waveformHeight) {\n                dirty = true;\n                canvasEle.style.height = waveformHeight + 'px';\n                canvasEle.height = waveformHeight;\n            }\n            if (canvasEle.width !== container.clientWidth) {\n                dirty = true;\n                canvasEle.style.width = container.clientWidth + 'px';\n                canvasEle.width = container.clientWidth;\n            }\n            if (dirty) {\n                cvsCtx.translate(.5, waveformHeight / 2);\n                cvsCtx.scale(.5, waveformHeight / 256);\n                cvsCtx.lineWidth = 2;\n            } else {\n                cvsCtx.setTransform(1, 0, 0, 1, 0, 0);\n                cvsCtx.translate(.5, waveformHeight / 2);\n                cvsCtx.scale(.5, waveformHeight / 256);\n            }\n\n            cvsCtx.clearRect(0, 0, canvasEle.width, canvasEle.height);\n            cvsCtx.strokeStyle = 'white';\n            cvsCtx.fillStyle = 'white';\n            const start = 0;\n            const end = container.clientWidth;\n            // const end = props.waveformWidth;\n            for (let e = start; e &#x3C; end; e += 1) {\n                // const ptr = 2 * (e % props.waveformWidth);\n                const ptr = 2 * (e % container.clientWidth);\n                let xPos = 2 * (e - start);\n                let top = peaks[ptr + 1];\n                let bottom = peaks[ptr];\n                if (top >= -.5 &#x26;&#x26; bottom &#x3C;= .5) {\n                    const i = xPos;\n                    for (; e &#x3C; end; e += 1) {\n                        // const a = 2 * (e % props.waveformWidth);\n                        const a = 2 * (e % container.clientWidth);\n                        if (peaks[a + 1] &#x3C; -.5 || peaks[a] > .5) {\n                            e -= 1;\n                            break;\n                        }\n                        xPos = 2 * (e - start);\n                    }\n                    if (i === xPos) {\n                        cvsCtx.moveTo(xPos, -.5);\n                        cvsCtx.lineTo(xPos, .5);\n                    } else {\n                        cvsCtx.stroke();\n                        cvsCtx.lineWidth = 1;\n                        cvsCtx.beginPath();\n                        cvsCtx.moveTo(i - .5, 0);\n                        cvsCtx.lineTo(xPos + .5, 0);\n                        cvsCtx.stroke();\n                        cvsCtx.lineWidth = 2;\n                        cvsCtx.beginPath();\n                    }\n                } else {\n                    if (top > -0.5) {\n                        top = -0.5;\n                    }\n                    if (bottom &#x3C; 0.5) {\n                        bottom = 0.5;\n                    }\n                    cvsCtx.moveTo(xPos, top);\n                    cvsCtx.lineTo(xPos, bottom);\n                }\n            }\n            cvsCtx.stroke();\n        }\n    }\n}\n</code></pre>\n<p>Besides, there is also a mini music player in Box3 editor implemented in a similar way.</p>\n<div class='m-5'></div>\n<img src=\"/images/audio-adjust/mini-player.gif\" alt=\"mini audio player\" style=\"width:320px; margin:auto\"/>\n<div class='m-5'></div>\n","title":"Audio Adjustment Tool","pic":"/images/audio-adjust/1.png","description":"This is a tool for uploading and simply processing audio in the box3 platform. The technology used is React and WebAudio API.","date":"2020-08-10"}},"__N_SSG":true}